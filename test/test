#!/bin/bash

## This is a small shunit library. It should suffice to itself, and focus
## on Doctest like tests. This is still in early alpha stage, and should be
## distributed in its own package only when achieving better maturity.

## TODO:
##  - global and local variables are all over and messed up and undocumented
##  - better statistics (usage of median ?)
##  - better measures... precision and what is measured.
##  - doc is needed

exname="$(basename $0)"

if ! [ -d "../pkg" ]; then
    echo "Please execute this in test directory, with './$exname'." >&2
    exit 1
fi
base=$(realpath "$PWD/..")

pos_args=()
PROFILE=${PROFILE:-}
SAVE=${SAVE:-}
while [ "$#" != 0 ]; do
    case "$1" in
        --help|-h)
            no_init=true ; no_hooks=true ; no_relations=true
            print_help
            exit 0
            ;;
        --profile|-p)
            export PROFILE=true
            ;;
        --filter|-f)
            export FILTER=$2
            shift
            ;;
        --version|-V)
            print_version
            exit 0
            ;;
        --save|-s)
            export PROFILE=true
            export SAVE="$2"
            shift
            ;;
        --diff|-d)
            export PROFILE=true
            export DIFF="$2"
            shift
            ;;
        -*|--*)
            echo "Invalid option '$1'." >&2
            exit 1
            ;;
        *)
            pos_args+=("$1")
            ;;
    esac
    shift
done


ansi_color_setup() {

    ESC=$'\e'
    UP=$ESC'[1A'
    if [ -t 1 ]; then
        ANSI_ESC=$ESC'['
        GRAY="${ANSI_ESC}1;30m"
        RED="${ANSI_ESC}1;31m"
        GREEN="${ANSI_ESC}1;32m"
        YELLOW="${ANSI_ESC}1;33m"
        BLUE="${ANSI_ESC}1;34m"
        PINK="${ANSI_ESC}1;35m"
        CYAN="${ANSI_ESC}1;36m"
        WHITE="${ANSI_ESC}1;37m"

        DARKGRAY="${ANSI_ESC}0;30m"
        DARKRED="${ANSI_ESC}0;31m"
        DARKGREEN="${ANSI_ESC}0;32m"
        DARKYELLOW="${ANSI_ESC}0;33m"
        DARKBLUE="${ANSI_ESC}0;34m"
        DARKPINK="${ANSI_ESC}0;35m"
        DARKCYAN="${ANSI_ESC}0;36m"

        NORMAL="${ANSI_ESC}0m"
    fi
}

line_setup() {
    SEP_LIST_ELT=""
    SEP_ELT_INFO=" "
    SEP_INFO_STATUS=" "
    SEP_STATUS_CHAR=" "

    SEP_LIST_ELT_SIZE=${#SEP_LIST_ELT}
    SEP_ELT_INFO_SIZE=${#SEP_ELT_INFO}
    SEP_INFO_STATUS_SIZE=${#SEP_INFO_STATUS}
    SEP_STATUS_CHAR_SIZE=${#SEP_STATUS_CHAR}

    ## If COLUMNS hasn't been set yet (bash sets it but not when
    ## called as sh), do it ourself
    if [ -z "$COLUMNS" ]; then

        ## Get the console device if we don't have it already. This is ok by the
        ## FHS as there is a fallback if /usr/bin/tty isn't available, for example
        ## at bootup.

        test -x /usr/bin/tty && CONSOLE=`/usr/bin/tty`
        test -z "$CONSOLE" && CONSOLE=/dev/console

        ## Get the console size (rows columns)

        stty size > /dev/null 2>&1
        if [ "$?" = 0 ]; then
            [ "$CONSOLE" = "/dev/console" ] && SIZE=$(stty size < $CONSOLE) \
                    || SIZE=$(stty size)

            ## Strip off the rows leaving the columns

            COLUMNS=${SIZE#*\ }
            LINES=${SIZE%\ *}
        else
            COLUMNS=80
            LINES=24
        fi
        export COLUMNS LINES SIZE
    fi

    SIZE_LINE=$COLUMNS                            ## full line size
    SIZE_INFO=20                                  ## zone info size in chars
    SIZE_STATUS=13                                ## status info size in chars
    SIZE_LIST=3                                   ## status list element
    SIZE_ELT=$[$SIZE_LINE - 1
               - $SIZE_INFO
               - $SIZE_STATUS
               - $SIZE_LIST
               - $SEP_LIST_ELT_SIZE
               - $SEP_ELT_INFO_SIZE
               - $SEP_INFO_STATUS_SIZE
               - $SEP_STATUS_CHAR_SIZE
            ]

    TEST_LINE_TEMPLATE=" - %-${SIZE_ELT}s $GRAY%-${SIZE_INFO}s$NORMAL "
    TEST_LINE_END_Q="[ $GRAY%8s$NORMAL ]\n"
    TEST_LINE_END_S="[ $DARKYELLOW%6s${NORMAL} s ]"
    TEST_LINE_END_dB="[ $DARKCYAN%5s${NORMAL} dB ]"
}

ansi_color_setup
line_setup


line_s() {
    local summary="$1" info="$2" s="$3"
    line "$summary" "$info" "$(printf "${TEST_LINE_END_S}" "${s:0:6}")"
}

line_db() {
    local summary="$1" info="$2" db="$3"
    line "$summary" "$info" "$(printf "${TEST_LINE_END_dB}" "${db:0:5}")"
}

line() {
    local before=
    if [ "$1" == "-n" ]; then
        shift
    else
        local before=$UP
    fi
    local summary="$1" info="$2" status="$3"
    printf "$before${TEST_LINE_TEMPLATE}%${SIZE_STATUS}s\n" "${summary:0:$SIZE_ELT}" "${info:0:$SIZE_INFO}" "$status"
}

##
## functions
##


empty_try_time_sum=0

calc() {
    echo "scale=$1; $2" | bc -l
    if [ "$?" != 0 ]; then
        echo "bc code:" >&2
        echo "$2" >&2
        exit 1
    fi
}

time_note() { calc 1 "l($1 - $empty_try_time) / l(10) - 3"; }
prefix() { local prefix=${1:-"  $GRAY|$NORMAL "}; sed -r "s/^/$prefix/g"; }

fn.cp() {
    local src="$1" dst="$2"
    eval "$(echo "$dst() " ; declare -f "$src" | tail -n +2)"
}

fn.exists() {
    declare -F "$1" >/dev/null
}


timing() {
    FORMAT='
fs.io.out     :%O: Nb of fs outputs
fs.io.in      :%I: Nb of fs inputs
mem.avg.tot   :%K: Avg mem total (data+stack+txt) (Kb)
mem.avg.data  :%D: Avg mem amount unshared data (Kb)
mem.avg.stack :%p: Avg mem amount of unshared stack (Kb)
mem.avg.txt   :%X: Avg mem amount of shared text (Kb)
mem.avg.rss   :%t: Avg mem amount resident set size (Kb)
mem.max.rss   :%M: Max mem amount resident set size (Kb)
pf.minor      :%R: Nb minor page faults
pf.major      :%F: Nb major page faults
cs.forced     :%c: Nb times context-switched involuntarily (ie: timeslice finished)
cs.asked      :%w: Nb times context-switched voluntarily (ie: for io)
sig           :%k: Nb signals delivered
sock.recv     :%r: Nb socket messages received
sock.sent     :%s: Nb socket messages sent
'
## These are more precise with bash 'time' keyword
# time.real     :%e: Real time elapsed
# time.kernel   :%S: time of CPU in system mode (seconds)
# time.user     :%U: time of CPU in user mode (seconds)

    /usr/bin/time -o "$tmp_profile" -f "$FORMAT" "$@"
}

declare -A __profile
declare -A __base_profile
declare -A __ref_profile
declare -A __stack_profile
declare -A __profile_new
declare -A __profile_last
declare -A __additional_profile


exists(){
  if [ "$2" != in ]; then
    echo "Incorrect usage." >&2
    echo "Correct usage: exists {key} in {array}" >&2
    return
  fi
  eval '[ ${'$3'[$1]+muahaha} ]'
}

load_profile() {
    local varname="$1"
    #declare -A "$varname"
    while IFS=':' read label value; do
        label=${label%% *}
        [ "$label" ] || continue
        [ "$label" != "Command" ] || continue
        # echo "$varname[\"$label\"]=$value"
        eval "$varname[\"$label\"]=$value"
    done < <(cat "$2" | cut -f 1,2 -d ":")
}

increment_profile() {
    local a="$1" b="$2" value base_value new_value
    for label in $(eval "echo \"\${!$b[@]}\""); do
        eval "value=\"\${$b[\"$label\"]}\""
        if ! exists "$label" in "$a"; then
            eval "$a[\"$label\"]=$value"
        else
            eval "base_value=\"\${$a[\"$label\"]}\""
            new_value="$(calc 3 "$value + $base_value")"
            eval "$a[\"$label\"]=$new_value"
        fi
    done
}

decrement_profile() {
    local a="$1" b="$2" value base_value new_value
    for label in $(eval "echo \"\${!$b[@]}\""); do
        eval "value=\"\${$b[\"$label\"]}\""
        if ! exists "$label" in "$a"; then
            eval "$a[\"$label\"]=$value"
        else
            eval "base_value=\"\${$a[\"$label\"]}\""
            new_value="$(calc 3 "$base_value - $value")"
            eval "$a[\"$label\"]=$new_value"
        fi
    done
}

cp_profile() {
    local a="$1" b="$2" value label
    for label in $(eval "echo \"\${!$a[@]}\""); do
        eval "value=\"\${$a[\"$label\"]}\""
        eval "$b[\"$label\"]=$value"
    done
}

divide_profile() {
    local a="$1" nb="$2" value new_value
    for label in $(eval "echo \"\${!$a[@]}\""); do
        eval "value=\"\${$a[\"$label\"]}\""
        new_value="$(calc 3 "$value / $nb")"
        eval "$a[\"$label\"]=$new_value"
    done
}

show_profile() {
    local a="$1"
    for label in $(eval "echo \"\${!$a[@]}\""); do
        eval "value=\"\${$a[\"$label\"]}\""
        echo "$label:$value"
    done | sort
}

dB_profile() {
    local a="$1" nb="$2" value new_value
    for label in $(eval "echo \"\${!$a[@]}\""); do
        eval "value=\"\${$a[\"$label\"]}\""
        if [ "$value" == "0" ]; then
            new_value=0
        else
            new_value="$(calc 1 "l($value) / l(10)")"
        fi
        eval "$a[\"$label\"]=$new_value"
    done
}

max_diff() {
    local a="$1" b="$2" value1 value2
    max_diff=0
    for label in $(eval "echo \"\${!$a[@]}\""); do
        eval "value1=\"\${$a[\"$label\"]}\""
        eval "value2=\"\${$b[\"$label\"]}\""
        value2=${value2:-0}
        diff=$(calc 1 "$value1 - $value2")
        diff=${diff#-}
        if [ "$(calc 0 "$diff > $max_diff")" == "1" ]; then
            max_diff="$diff"
            # echo "MAX DIFF: $max_diff ($label)" >&2
        fi
    done
    echo "$max_diff"
}

should_we_repeat() {
    local a="$1" b="$2" value repeat
    eval "value=\"\${$a[\"time.real\"]}\""
    repeat="$(calc 0 "l(200000) - $value" | cut -f 1 -d .)"
    if [ "$replay_count" -lt "$repeat" ]; then
        if [ "$repeat" != 0 -a "${repeat::1}" != "-" ]; then
            # echo "Will repeat because to small: $repeat ($value)" >&2
            echo "$repeat"
            return 0
        fi
    fi
    repeat="$(calc 0 "$(max_diff "$a" "$b") * 10" | cut -f 1 -d .)"
    if [ "$repeat" != 0 ]; then
        # echo "Will repeat because to still diff: $repeat" >&2
        echo "$repeat"
        return 0
    fi
    return 1
}

first_non_zero=
swallow_last_time() {
    total=${total:-0}
    ((total+=nb_assert))
    sum_time=${sum_time:-0}
    test_counter=${test_counter:-0}
    ((++test_counter))

    [ -e "$tmp_profile" ] || return 0
    load_profile __profile "$tmp_profile" || exit 1
    if [ "$sum_time" == "0" -a -z "$cmd" ]; then  ## catches first empty 'try'
        increment_profile __base_profile __profile
	    empty_try_time_sum="$(echo "scale=0 ; $empty_try_time_sum + $time_diff" | bc -l)"
        ((empty_try_time_count++))
	    empty_try_time="$(echo "scale=2 ; $empty_try_time_sum / $empty_try_time_count" | bc -l)"
	    return 0
    else
        if [ -z "$first_non_zero" ]; then
            divide_profile __base_profile "$empty_try_time_count"
            for label in time.system time.user; do
                if [ "${__base_profile[$label]}" == "1000.000" ]; then
                    __base_profile[$label]=0
                fi
            done
        fi
        first_non_zero=true
    fi
    nb_assert_string=$(printf "%4s asserts" "$nb_assert")
    decrement_profile __profile __base_profile
    if [ "$PROFILE" ]; then
        cp_profile __profile __stack_profile
        _last_timings_sec=${__profile[time.real]}
        dB_profile __profile
        cp_profile __profile __profile_new

        ## Consolidation of small values and stabilization
        __profile_last=()
        while replays=$(should_we_repeat __profile_new __profile_last); do
            while ((replays--)); do
                _last_timings=${__profile[time.real]}
                line_s "$test_name $test_desc" "replay $replay_count" "$_last_timings"
                _replay_last_test
                load_profile __additional_profile "$tmp_profile" || exit 1
                decrement_profile __additional_profile __base_profile
                increment_profile __stack_profile __additional_profile
                ((replay_count++))
            done
            cp_profile __profile_new __profile_last
            cp_profile __stack_profile __profile_new
            divide_profile __profile_new "$replay_count"
            _last_timings_sec=${__profile_new[time.real]}
            dB_profile __profile_new
        done
        cp_profile __profile_new __profile

        if [ "$SAVE" ]; then
            mkdir -p "$base/.profile/$SAVE" || exit 1
            show_profile __profile > "$base/.profile/$SAVE/$test_name" || exit 1
        fi

        _last_timings=${__profile[time.real]}
        line_s "$test_name $test_desc" "$nb_assert_string" "$_last_timings"
        if [ "$DIFF" ]; then
            load_profile __ref_profile "$base/.profile/$DIFF/$test_name"
            decrement_profile __ref_profile __profile
            value=
            while IFS=: read label value; do
                value="$(calc 0 "- $value")"  ## invert the diff
                if [ "${value::1}" == "-" ]; then
                    printf "  ${DARKGREEN}- %-15s %4s$NORMAL (%s)\n" "$label" "${value:1}" "${__profile[$label]}"
                else
                    printf "  ${DARKRED}+ %-15s %4s$NORMAL (%s)\n" "$label" "$value" "${__profile[$label]}"
                fi
            done < <(show_profile __ref_profile | grep -v ':0$')
        fi
	    sum_time=$(echo "scale=3; $sum_time + $_last_timings_sec" | bc -l )
    else
	    sum_time=$(echo "scale=3; $sum_time + $time_diff" | bc -l )
        value="$(calc 3 "${__profile[time.real]} / 1000000")"
        line_s "$test_name $test_desc" "$nb_assert_string" "$value"
    fi
}


## replays last test for profiling reasons
_replay_last_test() {
    local i cmdline save_nb_assert
    if fn.exists _last_setup; then
        _last_setup
    fi
    time_exec "$_last_prefix_cmd$cmd" 1> "$tmp_out" 2> "$tmp_err"
    echo -n $? > "$tmp_errlvl"
    if fn.exists _last_teardown; then
        _last_teardown
    fi
    save_nb_assert="$nb_assert"
    nb_assert=0
    for ((i=0; i<$save_nb_assert; i++)); do
        eval "cmdline=(\"\${assertion_$i[@]}\")"
        is "${cmdline[@]}"
    done
    nb_assert=$save_nb_assert
}

try() {
    if [ "$FILTER" ]; then
        if [[ "$2" =~ $FILTER ]]; then
            deactivate=
        else
            deactivate=true
            return 0
        fi
    else
        deactivate=
    fi
    swallow_last_time

    cmd="$1"
    nb_assert=0
    replay_count=1
    test_desc="$2"
    if [ "$cmd" ]; then
        if [ "$PROFILE" ]; then
            test_name=${test_file}_$({ echo "$cmd"; declare -f setup 2>&1 ; cat "$base/test/$exname"; } | md5sum | cut -c -16)
        else
            test_name=${test_file}_${test_counter}
        fi
        line -n "$test_name $test_desc" "running test"
    fi
    _last_prefix_cmd=$prefix_cmd
    if fn.exists setup; then
        fn.cp setup _last_setup
        line "$test_name $test_desc" "setup"
        setup
    else
        unset -f _last_setup 2>/dev/null
    fi
    time_exec "$prefix_cmd$cmd" 1> "$tmp_out" 2> "$tmp_err"
    echo -n $? > "$tmp_errlvl"
    if fn.exists teardown; then
        fn.cp teardown _last_teardown
        line "$test_name $test_desc" "teardown"
        teardown
    else
        unset -f _last_teardown  2>/dev/null
    fi
}

opt_NOCOLOR() { sed -r "s/$ESC\[[0-9]+(;[0-9]+)*m//g"; }
opt_NOPOS() { sed -r "s/$ESC\[[0-9]\+[GA]//g"; }
opt_TRIM() { sed -r "s/^ +//g" | sed -r "s/ +\$//g"; }
opt_SIZE() { wc -c; }

apply_opt() {
    code=$(cat -; echo 'x')
    code=${code::-1}
    for opt in "$@"; do
	    code=$(echo "$code" | opt_$opt; echo 'x')
        code=${code::-1}
    done
    echo -n "$code"
}

time_exec() {
    local x errlvl out
    exec 3>&1 4>&2
    out=$(TIMEFORMAT="%R %U %S"; { time timing bash -c "$*" 1>&3 2>&4; } 2>&1)
    errlvl=$?
    read r u s <<<$(echo "$out" | tr -d ".")
    for x in r u s; do
        [ "${!x}" == "0000" ] && eval "$x=1"
        eval "$x+=000"
    done
    # r+=000
    # u+=000
    # s+=000
    exec 3>&- 4>&-
    cat <<EOF >> "$tmp_profile"
time.real     :$r: Real time elapsed
time.system   :$s: time of CPU in system mode (nanoseconds)
time.user     :$u: time of CPU in user mode (nanoseconds)
time.wait     :$(calc 0 "$r - $s - $u"): time of CPU waiting for IO (nanoseconds)
EOF
    time_diff=$r
    return $errlvl
}


out() { cat "$tmp_out"; }
err() { cat "$tmp_err"; }
errlvl() { cat "$tmp_errlvl"; }
var() { echo "${!1}"; }

is() {
    if [ "$deactivate" == "true" ]; then
        return 0
    fi
    local act="$1" type code
    nb_assert=${nb_assert:-0}
    eval "assertion_${nb_assert}=(\"\$@\")"
    line "$test_name $test_desc" "assert is $act.."
    shift

    case "$1" in
        reg|part) type="$1"; shift;;
        *)        type="";;
    esac

    code="$1"
    shift
    #code=$(echo "$code" | apply_opt $*)
    msg=$(echo "$type $code" | cut -c -50)

    output=$($act | apply_opt $*; echo -n 'x')
    output=${output::-1}
    case "$type" in
	    "")      [ "$code" == "$output" ];;
        "part")  [[ "$output" == *"$code"* ]];;
	    "reg")   echo -n "$output" | egrep -- "$code" >/dev/null 2>&1;;
    esac && {
        ((++nb_assert))
        return 0
    }

    echo "${RED}Failed assertion:${NORMAL} ${YELLOW}is $act $type$NORMAL"
    echo "${WHITE}code$NORMAL"
    echo "$code" | sed -r "s/^/  $GRAY|$NORMAL /g"
    echo "expected ${WHITE}$act $type$NORMAL"
    echo "$code$GRAY\$$NORMAL" | sed -r "s/^/  $GRAY|$NORMAL /g";
    echo "real ${WHITE}$act$NORMAL $YELLOW$*$NORMAL"
    echo "$output$GRAY\$$NORMAL" | sed -r "s/^/  $GRAY|$NORMAL /g"
    echo "${WHITE}Diff$NORMAL expected real"
    diff -u <(echo "$code") <(echo "$output") | egrep -v '^(---|\+\+\+) /' \
        | sed -r "s/^(\@@.*)*$/$DARKCYAN\1$NORMAL/g;\
                  s/^\-(.*)*$/$RED-$NORMAL $DARKRED\1$NORMAL/g;
                  s/^\+(.*)*$/$GREEN+$NORMAL $DARKGREEN\1$NORMAL/g;
                  s/^ /$GRAY|$NORMAL /g;
                  s/^/  /g"
    exit 1
}

summary() {
    swallow_last_time

    # echo "$profiler_info"
    # echo
    echo "$YELLOW$total$NORMAL assertions ${DARKGREEN}passed$NORMAL." \
         "Code took $DARKYELLOW$(echo "scale=3;$sum_time/1000000" | bc)$NORMAL s" \
         "($DARKCYAN$(time_note $sum_time)$NORMAL dB)."
}

noerror() {
    is err ''
    is errlvl 0
}


declare -g libtest_tmpdir=$(mktemp -d)
declare -g test_tmpdir=$(mktemp -d)
trap -- "rm -rf \"$test_tmpdir\" \"$libtest_tmpdir\"" EXIT INT

tmp_out="$libtest_tmpdir/stdout"
tmp_err="$libtest_tmpdir/stderr"
tmp_errlvl="$libtest_tmpdir/errlvl"
tmp_profile="$libtest_tmpdir/profile"


## keeps those empty 'try': they are are ways to estimate the
## time taken by the system.
try ''
if [ "$PROFILE" ]; then
    ## be more precise for profile mode (at cost of time of execution)
    try ''
    try ''
    try ''
    try ''
fi

if [ -z "${pos_args[*]}" ]; then
    pos_args=(*)
fi

for test_file in "${pos_args[@]}"; do
    cd "$base/test"
    if ! [ -e "${test_file}" ]; then
        echo "${RED}Error$NORMAL: No test file named '${test_file}'." >&2
        exit 1
    fi
    [ -x "${test_file}" ] && continue
    test_counter=0
    source "./${test_file}"
    swallow_last_time
done

summary
